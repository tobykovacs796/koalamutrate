```{r}
#install.packages("vcfR")
#install.packages("dartR") ## isn't available for this version of R
#install.packages("SNPRelate")
#install.packages("poppr")

#install.packages("githubinstall")
#library(githubinstall)
#githubinstall("RSplitsTree")


library(vcfR)

setwd("~/OneDrive - The University of Sydney (Staff)/1_PhD/koala/mutation_rate/Demographics/Koala_SplitsTree/data")

library(dplyr)
library(vcfR)
library(poppr)
library(adegenet)
library(RSplitsTree)

# read in the vcf and then convert it to a genlight object
vcf <- read.vcfR("koala-joint-genotyping-474-thin10kb_15-60depth_100cr_1mac_0.005maf.vcf.gz", verbose = FALSE)
genlight <- vcfR2genlight(vcf)
rm(vcf)

#check out the format of the genlight object
genlight[1:10]

#I'm not sure if you need to do this
#ploidy(genlight) <- 2

#Estimate the genetic distances (euclidean) between individuals in the population
genlight.dist <- poppr::bitwise.dist(genlight, euclidean = TRUE)

## Write a splitstree input file
splitstree(genlight.dist, nexus.file = "splitstreethin10kb_15-60depth_100cr_1mac_0.005maf.nex")

### remove captive breed individuals
# Convert the dist object to a matrix
dist_matrix <- as.matrix(genlight.dist)

# Identify individuals containing "Narrandra", "TarZoo", or "FWP" in their names
to_remove <- grep("Narrandra|TarZoo|FWP", rownames(dist_matrix), value = TRUE)

# Subset to keep only individuals NOT in 'to_remove'
filtered_matrix <- dist_matrix[!(rownames(dist_matrix) %in% to_remove), 
                               !(colnames(dist_matrix) %in% to_remove)]

# Convert back to 'dist' object
filtered_dist <- as.dist(filtered_matrix)

# Check that "Narrandra", "TarZoo", and "FWP" individuals are removed
labels(filtered_dist)

## Write a splitstree input file
splitstree(genlight.dist, nexus.file = "splitstreethin10kb_15-60depth_QUAL_100cr_wild_noNar.nex")





#########################
# read in the vcf and then convert it to a genlight object
vcf <- read.vcfR("koala-joint-genotyping-474-thin10kb_15-60depth_QUAL_100cr.vcf.gz", verbose = FALSE)
genlight <- vcfR2genlight(vcf)
rm(vcf)

#check out the format of the genlight object
genlight[1:10]

#I'm not sure if you need to do this
#ploidy(genlight) <- 2

#Estimate the genetic distances (euclidean) between individuals in the population
genlight.dist <- poppr::bitwise.dist(genlight, euclidean = TRUE)

## Write a splitstree input file
splitstree(genlight.dist, nexus.file = "splitstreethin10kb_15-60depth_QUAL_100cr.nex")



str(genlight.dist)
labels(genlight.dist)


# Convert the dist object to a matrix
dist_matrix <- as.matrix(genlight.dist)

# Identify individuals containing "Narrandra", "TarZoo", or "FWP" in their names
to_remove <- grep("Narran|TarZoo|FWP", rownames(dist_matrix), value = TRUE)

# Subset to keep only individuals NOT in 'to_remove'
filtered_matrix <- dist_matrix[!(rownames(dist_matrix) %in% to_remove), 
                               !(colnames(dist_matrix) %in% to_remove)]

# Convert back to 'dist' object
filtered_dist <- as.dist(filtered_matrix)

# Check that "Narrandra", "TarZoo", and "FWP" individuals are removed
labels(filtered_dist)

## Write a splitstree input file
splitstree(filtered_dist, nexus.file = "splitstreethin10kb_15-60depth_QUAL_100cr_wild_noNar.nex")


```

```{r}

##checking the data in various ways
#find the lowest genetic distances 
# Assume `dist_matrix` is your genlight.dist object converted to a matrix
dist_matrix <- as.matrix(genlight.dist)

# Number of lowest values to retrieve
n <- 20  # Adjust this to however many lowest values you want

# Sort the matrix and retrieve the lowest values
sorted_values <- sort(as.vector(dist_matrix), decreasing = FALSE)

# Get the n lowest values (excluding self-distances, i.e., diagonal = 0)
lowest_values <- sorted_values[sorted_values > 0][1:n]

# Loop through the lowest values and print the row/column names
for (val in lowest_values) {
  idx <- which(dist_matrix == val, arr.ind = TRUE)
  
  # Ensure not to include self-distances (i.e., identical rows and columns)
  if (idx[1] != idx[2]) {
    cat("Distance:", val, "\n")
    cat("Between:", rownames(dist_matrix)[idx[1]], "and", colnames(dist_matrix)[idx[2]], "\n\n")
  }
}


#Turn the distances into a matrix so you can have a look
#write.csv(dist_matrix, file = "data/dist_matrix100kb.csv", row.names = TRUE)


```

```{r}
## Plotting the output of Splitstree
# trees of various kinds

# Splitstree ###################################################################

# Visualise splitstre in R #######################################################
library(tanggle)
library(RSplitsTree)

Nnet <- phangorn::read.nexus.networx('splitstreethin10kb_15-60depth_QUAL_100cr.nex')

network_df <- data.frame(x=Nnet$.plot$vertices[,1], y=Nnet$.plot$vertices[,2], 
                ind=rep(NA, nrow(Nnet$.plot$vertices)))

network_df[Nnet$translate$node,"ind"] <- Nnet$translate$label

pops <- read.table("wild_413_populations_faststructureK5_edits.tsv", header = TRUE, sep = "\t", stringsAsFactors = FALSE)

network_df <- merge(network_df, pops, by="ind", all.x=TRUE, all.y=FALSE)


network_df_6pops_capt <- network_df %>%
  mutate(state = case_when(  # Update specific individuals
    ind == "Dubbo_U_C11512" ~ "M_NSW",
    ind == "Dubbo_U_C11413" ~ "S_NSW",
    ind == "Dubbo_U_C11358" ~ "S_NSW",
    ind == "Dubbo_U_C11212" ~ "S_NSW",
    ind == "Dubbo_U_C11085" ~ "M_NSW",
    TRUE ~ state  # Keep other values unchanged
  )) 


net_x_axis <- max(network_df_6pops_capt$x)-min(network_df_6pops_capt$x)
net_y_axis <- max(network_df_6pops_capt$y)-min(network_df_6pops_capt$y)

network_df_6pops_capt_filtered <- network_df_6pops_capt[!is.na(network_df_6pops_capt$state),]

hull <- network_df_6pops_capt_filtered %>% group_by(state) %>% 
  slice(chull(x, y))


# Calculate plot center (midpoint of the limits)
plot_center_x <- (min(network_df_6pops_capt_filtered$x) - 0.1 * net_x_axis + max(network_df_6pops_capt_filtered$x) + 0.1 * net_x_axis) / 2
plot_center_y <- (min(network_df_6pops_capt_filtered$y) - 0.1 * net_y_axis + max(network_df_6pops_capt_filtered$y) + 0.1 * net_y_axis) / 2


# Find the point on the convex hull that is furthest from the center
furthest_points <- hull %>%
  group_by(state) %>%
  slice(chull(x, y)) %>%  # chull() gives indices of points that make up the convex hull
  mutate(distance_from_center = sqrt((x - plot_center_x)^2 + (y - plot_center_y)^2)) %>%
  slice_max(distance_from_center, n = 1)

library(RColorBrewer)
library(ggforce)

# Define populations in order from north to south
pop_order <- c("N_QLD", "SEQLD_FNNSW", "M_NSW", "S_NSW", "VIC", "SA","Trios","Narrandra","")

# Assign colors using a Spectral palette
spectral_colors <- rev(brewer.pal(length(pop_order), "Spectral"))  # Reverse for north-to-south

# Ensure 'Population' is a factor with the correct order
network_df_6pops_capt$state <- factor(network_df_6pops_capt$state, levels = pop_order)

  ggplot(Nnet, mapping = aes_(~x, ~y), layout = "slanted", mrsd = NULL, 
                          as.Date = FALSE, yscale = "none", yscale_mapping = NULL, 
                          ladderize = FALSE, right = FALSE, branch.length = "branch.length", 
                          ndigits = NULL)+
  geom_shape(data = hull, alpha = 0.4, expand = 0.025, radius = 0.015, aes(fill = state, color = "transparent")) +
  geom_splitnet(layout = "slanted", size=0.2)+
  geom_point(data = network_df_6pops_capt_filtered, shape=19, color="white", size=2.5) +
  geom_point(data = network_df_6pops_capt_filtered, aes(x, y, colour = state), size = 0.8)+  # Adjust size as needed
  scale_colour_manual(values=spectral_colors, na.translate=FALSE,
  guide = guide_legend("Genetic group"))+
  theme_void()+
  expand_limits(x=c(min(x$x)-0.05*net_x_axis, max(x$x)+0.05*net_x_axis),
                y=c(min(x$y)-0.05*net_y_axis, max(x$y)+0.05*net_y_axis))+
  theme(legend.text = element_text(face="italic"), legend.position = "top")+coord_fixed()
  

ggplot(Nnet, aes(x = x, y = y)) +
  #geom_shape(data = hull, alpha = 0.4, expand = 0.015, radius = 0.015,
  #           aes(fill = state, color = "transparent")) +
  #geom_point(data = network_df_6pops_capt_filtered, shape=19, color="white", size=2.5) +
  geom_splitnet(layout = "slanted", size = 0.4) +
  geom_point(data = network_df_6pops_capt_filtered, aes(color = state)) +
  scale_fill_manual(values = spectral_colors, na.translate = FALSE) +
  scale_colour_manual(values = spectral_colors, na.translate = FALSE) +
  theme_void() +
  coord_flip() +
  theme(
    legend.position = "none",
    legend.key = element_blank(),
    legend.text = element_text(face = "italic"),  # Italicize legend labels
    legend.key.size = unit(0.5, 'lines'), legend.key.height = unit(0.5, 'lines')
  ) +
  labs(color = "genetic group", shape = "genetic group", fill = "") +
  guides(colour = guide_legend(title.position = "top", nrow = 4, override.aes = list(fill = NA, linetype = 0)),
         fill = "none",
         shape = guide_legend(title.position = "top", nrow = 4))+
  theme(aspect.ratio = (net_x_axis)/(net_y_axis))+
  scale_x_continuous(expand=c(0.2,0.2))+
  scale_y_continuous(expand=c(0.2,0.2))


    
ggsave("genetic_network_plot.pdf", width = 8, height = 6, bg = "transparent")
ggsave("genetic_network_plot.png", width = 8, height = 6, bg = "transparent")


```

